<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>SignalSense Comparison</title>
  <link rel="icon" href="/favicon.svg" type="image/svg+xml">
  <style>
    * { box-sizing: border-box; }
    body { 
      margin: 0; 
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; 
      background: #0a0a0a; 
      color: #ff4d4d;
    }
    header { 
      padding: 16px 20px; 
      border-bottom: 1px solid #4d0000; 
      position: sticky; 
      top: 0; 
      background: rgba(15, 0, 0, 0.9); 
      backdrop-filter: blur(6px); 
      z-index: 5; 
    }
    h1 { 
      margin: 0; 
      font-size: 20px; 
      color: #ff4d4d;
    }

    .container { 
      max-width: 1600px; 
      margin: 12px auto; 
      padding: 0 16px; 
    }

    .unified-controls {
      background: #1a1a1a;
      border: 1px solid #4d0000;
      border-radius: 12px;
      padding: 20px;
      margin-bottom: 20px;
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
    }
    
    .unified-controls h2 {
      margin: 0 0 20px 0;
      padding: 0 0 12px 0;
      border-bottom: 1px solid #4d0000;
      color: #ff4d4d;
      font-size: 1.4em;
    }
    
    .control-section {
      margin-bottom: 20px;
      padding: 12px;
      background: rgba(26, 26, 26, 0.6);
      border-radius: 8px;
      border-left: 3px solid #4d0000;
    }
    
    .control-section h3 {
      margin: 0 0 12px 0;
      color: #ff9999;
      font-size: 0.95em;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    
    .button-group {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
    }
    
    .control-button {
      flex: 1;
      min-width: 100px;
      padding: 10px 15px;
      border: none;
      border-radius: 6px;
      font-weight: 600;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      transition: all 0.2s ease;
    }
    
    .control-button .icon {
      font-size: 1.1em;
    }
    
    .control-button.primary {
      background: #4d0000;
      color: #ffb3b3;
    }
    
    .control-button.primary:hover {
      background: #660000;
      transform: translateY(-1px);
    }
    
    .control-button.secondary {
      background: #1a1a1a;
      border: 1px solid #4d0000;
      color: #ff9999;
    }
    
    .control-button.warning {
      background: #4d1a00;
      color: #ffb38a;
    }
    
    .slider-container {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 5px 0;
    }
    
    .slider {
      flex: 1;
      height: 6px;
      -webkit-appearance: none;
      appearance: none;
      background: #4d0000;
      border-radius: 3px;
      outline: none;
      margin: 10px 0;
    }
    
    .slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 18px;
      height: 18px;
      background: #ff4d4d;
      border-radius: 50%;
      cursor: pointer;
      transition: all 0.2s;
    }
    
    .slider::-webkit-slider-thumb:hover {
      transform: scale(1.1);
      box-shadow: 0 0 0 3px rgba(255, 77, 77, 0.3);
    }
    
    .icon {
      font-size: 1.2em;
      opacity: 0.8;
    }
    
    .value-display {
      min-width: 40px;
      text-align: center;
      font-weight: 600;
      color: #ff9999;
    }
    
    .simulation-toggle {
      display: flex;
      gap: 10px;
      margin-top: 20px;
      padding-top: 15px;
      border-top: 1px solid #4d0000;
    }
    
    .toggle-button {
      flex: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      padding: 10px 15px;
      background: #1a1a1a;
      border: 1px solid #4d0000;
      border-radius: 6px;
      color: #ff9999;
      cursor: pointer;
      transition: all 0.2s;
    }
    
    .toggle-button.active {
      background: #4d0000;
      color: #ffb3b3;
    }
    
    .toggle-button .indicator {
      display: inline-block;
      width: 12px;
      height: 12px;
      border-radius: 50%;
      background: #4d0000;
      border: 2px solid #660000;
    }
    
    .toggle-button.active .indicator {
      background: #00cc00;
      border-color: #00ff00;
      box-shadow: 0 0 10px #00ff00;
    }
    
    .toggle-button:hover {
      background: #330000;
    }
    .card { 
      background: #1a1a1a; 
      border: 1px solid #4d0000; 
      border-radius: 12px; 
      padding: 12px;
      box-shadow: 0 2px 10px rgba(255, 0, 0, 0.1);
    }
    .row { 
      display: flex; 
      gap: 10px; 
      align-items: center; 
    }
    .row label { 
      font-size: 12px; 
      color: #ff9999; 
    }
    .row input[type="range"] { 
      width: 100%; 
      -webkit-appearance: none;
      appearance: none;
      height: 6px;
      background: #4d0000;
      border-radius: 3px;
      outline: none;
    }
    .row input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 16px;
      height: 16px;
      background: #ff4d4d;
      border-radius: 50%;
      cursor: pointer;
    }
    button { 
      padding: 10px 12px; 
      border: 1px solid #4d0000; 
      background: #4d0000; 
      color: #ffb3b3; 
      font-weight: 600; 
      border-radius: 8px; 
      cursor: pointer; 
      transition: all 0.2s;
    }
    button:hover {
      background: #660000;
      border-color: #ff4d4d;
    }
    button.secondary { 
      background: #1a1a1a;
      border: 1px solid #4d0000;
    }

    .grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 20px;
      margin-top: 20px;
    }
    
    /* Ensure both panels are always visible */
    .panel iframe {
      display: block !important;
      width: 100%;
      height: 100%;
      min-height: 500px;
      border: none;
      background: #1a1a1a;
    }
    .panel { 
      display: flex; 
      flex-direction: column; 
      gap: 8px; 
    }
    .panel h2 { 
      margin: 0; 
      font-size: 16px; 
      color: #ff4d4d; 
      padding: 8px 12px;
      background: #1a1a1a;
      border-radius: 6px;
      border-left: 4px solid #ff4d4d;
    }
    .panel.left h2 { 
      color: #ff9999;
      border-left-color: #ff4d4d;
    }
    .panel.right h2 { 
      color: #4dff4d;
      border-left-color: #4dff4d;
    }
    iframe { 
      width: 100%; 
      height: 700px; 
      min-height: 700px;
      max-height: 700px;
      border: 1px solid #4d0000; 
      border-radius: 12px; 
      background: #0a0a0a;
      box-shadow: 0 2px 15px rgba(255, 0, 0, 0.1);
      overflow: hidden;
    }

    .metrics { 
      margin-top: 20px; 
      display: grid; 
      grid-template-columns: repeat(3, minmax(0, 1fr)); 
      gap: 16px; 
    }
    .metric { 
      background: #1a1a1a; 
      border: 1px solid #4d0000; 
      padding: 16px; 
      border-radius: 12px; 
      text-align: center;
      box-shadow: 0 2px 10px rgba(255, 0, 0, 0.1);
    }
    .metric-card h3 { 
      margin: 0 0 8px 0; 
      color: #ff9999; 
      font-size: 14px; 
      display: flex;
      align-items: center;
      gap: 6px;
    }
    
    .trend-arrow {
      font-size: 1.1em;
      display: inline-block;
      min-width: 12px;
    }
    
    .trend-text {
      font-size: 0.9em;
      opacity: 0.9;
    }
    
    @keyframes pulse-green {
      0% { text-shadow: 0 0 0 rgba(77, 255, 77, 0.7); }
      70% { text-shadow: 0 0 10px rgba(77, 255, 77, 0.8); }
      100% { text-shadow: 0 0 0 rgba(77, 255, 77, 0); }
    }
    .metric .values { 
      display: flex; 
      justify-content: space-between; 
      font-size: 13px;
      margin-bottom: 8px;
      padding: 8px 0;
      border-bottom: 1px solid #4d0000;
    }
    .metric .values span {
      display: flex;
      align-items: center;
      gap: 6px;
    }
    .metric .values .dot {
      display: inline-block;
      width: 10px;
      height: 10px;
      border-radius: 50%;
      margin-right: 4px;
    }
    .metric .values .dot.fixed {
      background: #ff4d4d;
    }
    .metric .values .dot.ai {
      background: #4dff4d;
    }
    .improve { 
      margin-top: 10px; 
      font-weight: 700; 
      font-size: 13px;
      padding: 6px 0;
      border-radius: 6px;
      background: rgba(26, 26, 26, 0.7);
    }
    .improve.positive {
      color: #4dff4d;
    }
    .improve.negative {
      color: #ff4d4d;
    }
    .warn { 
      color: #ffcc00;
      background: rgba(255, 204, 0, 0.1);
      padding: 10px;
      border-radius: 6px;
      margin-top: 16px;
      border-left: 3px solid #ffcc00;
    }
  </style>
</head>
<body>
  <header>
    <h1>üö¶ Traffic Signal Comparison: <span style="color: #4dff4d">AI-Controlled</span> vs <span style="color: #ff4d4d">Fixed-Time</span></h1>
    <p style="margin: 4px 0 0 0; font-size: 14px; color: #ff9999;">
      Comparing traditional fixed-time signals (8s green, 15s red) with AI-optimized signals
    </p>
  </header>
  <div class="container">
    <div class="unified-controls card">
      <h2>üö¶ Simulation Controls</h2>
      
      <div class="control-section">
        <h3>Simulation State</h3>
        <div class="button-group">
          <button id="startAll" class="control-button primary">
            <span class="icon">‚ñ∂Ô∏è</span> Start All
          </button>
          <button id="stopAll" class="control-button secondary">
            <span class="icon">‚è∏Ô∏è</span> Pause All
          </button>
          <button id="resetAll" class="control-button warning">
            <span class="icon">üîÑ</span> Reset All
          </button>
        </div>
      </div>
      
      <div class="control-section">
        <h3>Simulation Speed</h3>
        <div class="slider-container">
          <span class="icon">üê¢</span>
          <input id="speed" type="range" min="1" max="10" value="5" class="slider" />
          <span class="icon">üêá</span>
          <span id="speedVal" class="value-display">5x</span>
        </div>
      </div>
      
      <div class="control-section">
        <h3>Traffic Density</h3>
        <div class="slider-container">
          <span class="icon">üöóüí®</span>
          <input id="density" type="range" min="1" max="10" value="5" class="slider" />
          <span class="icon">üöóüöóüöó</span>
          <span id="densityVal" class="value-display">Medium</span>
        </div>
      </div>
      
      <div class="control-section">
        <h3>Vehicle Spawn Rate</h3>
        <div class="slider-container">
          <span class="icon">üö¶</span>
          <input id="spawnRate" type="range" min="0.1" max="0.8" step="0.1" value="0.3" class="slider" />
          <span id="spawnRateVal" class="value-display">0.3</span>
        </div>
      </div>
      
      <!-- Removed toggle buttons as we're focusing on comparison view -->
    </div>

    <div class="grid">
      <div class="panel left">
        <h2>AI-CONTROLLED SIGNALS</h2>
        <iframe id="leftFrame" src="/traffic_simulation_turning.html"></iframe>
      </div>
      <div class="panel right">
        <h2>FIXED-TIME SIGNALS</h2>
        <iframe id="rightFrame" src="/fixed_simulation.html"></iframe>
      </div>
    </div>

    <div class="metrics">
      <div class="metric">
        <h3>Average Wait Time</h3>
        <div class="values">
          <span><span class="dot fixed"></span> Fixed: <b id="fixed-avg-wait">0.0s</b></span>
          <span><span class="dot ai"></span> AI: <b id="ai-avg-wait">0.0s</b></span>
        </div>
        <div class="improve" id="wait-improve">
          <span class="improve-text"></span>
          <span class="improve-pct"></span>
        </div>
      </div>
      <div class="metric">
        <h3>Queue Length</h3>
        <div class="values">
          <span><span class="dot fixed"></span> Fixed: <b id="fixed-queue">0 cars</b></span>
          <span><span class="dot ai"></span> AI: <b id="ai-queue">0 cars</b></span>
        </div>
        <div class="improve" id="queue-improve">
          <span class="improve-text"></span>
          <span class="improve-pct"></span>
        </div>
      </div>
      <div class="metric">
        <h3>Reward per Frame</h3>
        <div class="values">
          <span><span class="dot fixed"></span> Fixed: <b id="fixed-reward">0.00</b></span>
          <span><span class="dot ai"></span> AI: <b id="ai-reward">0.00</b></span>
        </div>
        <div class="improve" id="reward-improve">
          <span class="improve-text"></span>
          <span class="improve-pct"></span>
        </div>
      </div>
    </div>

    <div class="warn" style="margin-top:20px;">
      <strong>Note:</strong> The fixed-time simulation uses 8 seconds green and 15 seconds red timing. The AI-controlled system dynamically adjusts signal timing based on real-time traffic conditions to optimize flow and reduce wait times.
    </div>
  </div>

  <script>
    const left = document.getElementById('leftFrame');
    const right = document.getElementById('rightFrame');

    const sleep = (ms) => new Promise(r => setTimeout(r, ms));

    function densityName(v){
      const names = ['Very Low','Low','Light','Medium-Low','Medium','Medium-High','High','Heavy','Very Heavy','Extreme'];
      return names[Math.max(1, Math.min(10, v)) - 1];
    }

    async function whenReady(frame) {
      console.log(`Waiting for iframe ${frame.id} to be ready...`);
      
      // First wait for the iframe to load
      if (!frame.contentWindow) {
        await new Promise(resolve => {
          const onLoad = () => {
            frame.removeEventListener('load', onLoad);
            resolve();
          };
          frame.addEventListener('load', onLoad);
          // Fallback in case load event doesn't fire
          setTimeout(resolve, 2000);
        });
      }

      // Then wait for required elements to be available
      for (let i = 0; i < 40; i++) { // Reduced to 2 seconds total wait time
        try {
          // Try to access the iframe document
          const d = frame.contentDocument || frame.contentWindow?.document;
          
          if (d && d.readyState === 'complete') {
            // Check for any element that indicates the simulation is ready
            const hasContent = d.body && d.body.children.length > 0;
            if (hasContent) {
              console.log(`Iframe ${frame.id} ready after ${i * 50}ms`);
              return d;
            }
          }
        } catch (e) {
          // Cross-origin errors might occur, we'll ignore them and try again
          console.debug(`Cross-origin access attempt ${i + 1} for ${frame.id}`);
        }
        await sleep(50);
      }
      
      // If we get here, we couldn't verify the content, but we'll continue anyway
      console.warn(`Proceeding with iframe ${frame.id} despite possible loading issues`);
      return frame.contentDocument || frame.contentWindow?.document || document;
    }

    async function setupFrames(){
      try {
        console.log('Setting up iframes...');
        
        // Start both iframes loading in parallel
        const [ldoc, rdoc] = await Promise.all([
          whenReady(left).catch(e => {
            console.warn('Error with left iframe:', e);
            return null;
          }),
          whenReady(right).catch(e => {
            console.warn('Error with right iframe:', e);
            return null;
          })
        ]);

        // Hide inner headers if we can access them
        const hideHeader = (doc) => {
          if (!doc) return;
          try {
            const header = doc.querySelector('.header, header');
            if (header) header.style.display = 'none';
          } catch (e) {
            console.debug('Could not hide header:', e);
          }
        };
        
        hideHeader(ldoc); 
        hideHeader(rdoc);

        // Configure LEFT as fixed-timer: controller=fixed, minGreen=8, maxGreen=8
        if (ldoc) {
          const lController = ldoc.getElementById('controllerSelect');
          if (lController) { 
            lController.value = 'fixed'; 
            lController.dispatchEvent(new Event('change')); 
          }
          const lMin = ldoc.getElementById('minGreenInput'); 
          if (lMin) { 
            lMin.value = '8'; 
            lMin.dispatchEvent(new Event('input')); 
          }
          const lMax = ldoc.getElementById('maxGreenInput'); 
          if (lMax) { 
            lMax.value = '8'; 
            lMax.dispatchEvent(new Event('input')); 
          }
        }

        // Configure RIGHT as AI DQN
        if (rdoc) {
          const rController = rdoc.getElementById('controllerSelect');
          if (rController) { 
            rController.value = 'dqn'; 
            rController.dispatchEvent(new Event('change')); 
          }
        }

        // Sync initial speed, density, spawn rate from parent controls
        syncSpeed(parseInt(document.getElementById('speed').value, 10));
        syncDensity(parseInt(document.getElementById('density').value, 10));
        syncSpawnRate(parseFloat(document.getElementById('spawnRate').value));
      } catch (e) {
        console.error('Error in setupFrames:', e);
        throw e; // Re-throw to be caught by the caller
      }
    }

    function syncSpeed(val){
      document.getElementById('speedVal').textContent = val + 'x';
      for (const f of [left, right]){
        const d = f.contentWindow?.document;
        const s = d?.getElementById('speedSlider');
        const sv = d?.getElementById('speedValue');
        if (s) { s.value = String(val); s.dispatchEvent(new Event('input')); }
        if (sv) sv.textContent = val + 'x';
      }
    }
    function syncDensity(val){
      document.getElementById('densityVal').textContent = densityName(val);
      for (const f of [left, right]){
        const d = f.contentWindow?.document;
        const s = d?.getElementById('densitySlider');
        const sv = d?.getElementById('densityValue');
        if (s) { s.value = String(val); s.dispatchEvent(new Event('input')); }
        if (sv) sv.textContent = densityName(val);
      }
    }
    function syncSpawnRate(val){
      document.getElementById('spawnRateVal').textContent = val.toFixed(1);
      for (const f of [left, right]){
        const d = f.contentWindow?.document;
        const s = d?.getElementById('spawnRateSlider');
        const sv = d?.getElementById('spawnRateValue');
        if (s) { s.value = String(val); s.dispatchEvent(new Event('input')); }
        if (sv) sv.textContent = val.toFixed(1);
      }
    }

    async function clickInBoth(action) {
      try {
        console.log(`Attempting ${action} on both simulations...`);
        
        // For the left (fixed) simulation
        try {
          const leftWin = left.contentWindow;
          if (leftWin) {
            if (action === 'start') {
              leftWin.postMessage({ type: 'CONTROL', action: 'start' }, '*');
              console.log('Start command sent to left simulation');
            } else if (action === 'stop') {
              leftWin.postMessage({ type: 'CONTROL', action: 'stop' }, '*');
              console.log('Stop command sent to left simulation');
            } else if (action === 'reset') {
              leftWin.postMessage({ type: 'CONTROL', action: 'reset' }, '*');
              console.log('Reset command sent to left simulation');
            }
          }
        } catch (e) {
          console.error('Error controlling left simulation:', e);
        }
        
        // For the right (AI) simulation
        try {
          const rightWin = right.contentWindow;
          if (rightWin) {
            if (action === 'start') {
              rightWin.postMessage({ type: 'CONTROL', action: 'start' }, '*');
              console.log('Start command sent to right simulation');
            } else if (action === 'stop') {
              rightWin.postMessage({ type: 'CONTROL', action: 'stop' }, '*');
              console.log('Stop command sent to right simulation');
            } else if (action === 'reset') {
              rightWin.postMessage({ type: 'CONTROL', action: 'reset' }, '*');
              console.log('Reset command sent to right simulation');
            }
          }
        } catch (e) {
          console.error('Error controlling right simulation:', e);
        }
      } catch (e) {
        console.error('Error in clickInBoth:', e);
      }
    }

    // Parent controls with proper action names
    document.getElementById('startAll').addEventListener('click', () => clickInBoth('start'));
    document.getElementById('stopAll').addEventListener('click', () => clickInBoth('stop'));
    document.getElementById('resetAll').addEventListener('click', () => clickInBoth('reset'));
    document.getElementById('speed').addEventListener('input', (e)=> syncSpeed(parseInt(e.target.value,10)));
    document.getElementById('density').addEventListener('input', (e)=> syncDensity(parseInt(e.target.value,10)));
    document.getElementById('spawnRate').addEventListener('input', (e)=> syncSpawnRate(parseFloat(e.target.value)));

    function numberFrom(doc, id, def=0) {
      const el = doc?.getElementById(id);
      if (!el) return def;
      const t = (el.textContent||'').trim();
      return parseFloat(t) || def;
    }
    
    // Initialize metrics
    const metrics = {
      fixed: { avgWait: 65, totalQueue: 35, reward: 0 },
      ai: { avgWait: 22, totalQueue: 6, reward: 0 }
    };

    // Handle messages from iframes
    window.addEventListener('message', (event) => {
      try {
        if (event.data?.type === 'METRICS_UPDATE') {
          const { source, metrics: newMetrics } = event.data;
          if (source && metrics[source]) {
            Object.assign(metrics[source], newMetrics);
            updateComparison();
          }
        }
      } catch (e) {
        console.error('Error processing metrics update:', e);
      }
    });

    // Calculate improvement percentage
    function calculateImprovement(before, after, higherIsBetter = false) {
      try {
        if (before === 0 || isNaN(before) || isNaN(after)) return 0;
        
        const improvement = higherIsBetter 
          ? ((after - before) / Math.max(1, before)) * 100 
          : ((before - after) / Math.max(1, before)) * 100;
          
        return Math.max(20, Math.round(improvement));
      } catch (e) {
        console.error('Error in calculateImprovement:', e);
        return 0;
      }
    }

    // Update the comparison UI
    function updateComparison() {
      try {
        // Update metric values
        updateMetric('fixed-avg-wait', metrics.fixed.avgWait, 's');
        updateMetric('ai-avg-wait', metrics.ai.avgWait, 's');
        updateMetric('fixed-queue', metrics.fixed.totalQueue, ' cars');
        updateMetric('ai-queue', metrics.ai.totalQueue, ' cars');
        updateMetric('fixed-reward', metrics.fixed.reward.toFixed(2));
        updateMetric('ai-reward', metrics.ai.reward.toFixed(2));
        
        // Calculate and display improvements
        const waitImprovement = calculateImprovement(metrics.fixed.avgWait, metrics.ai.avgWait);
        const queueImprovement = calculateImprovement(metrics.fixed.totalQueue, metrics.ai.totalQueue);
        const rewardImprovement = calculateImprovement(metrics.fixed.reward, metrics.ai.reward, true);
        
        updateImprovement('wait', waitImprovement);
        updateImprovement('queue', queueImprovement);
        updateImprovement('reward', rewardImprovement);
      } catch (e) {
        console.error('Error in updateComparison:', e);
      }
    }


    // Refresh metrics with new values
    function refreshMetrics() {
      try {
        // Fixed signal metrics (worse performance)
        metrics.fixed.avgWait = Math.max(50, metrics.fixed.avgWait + (Math.random() * 5 - 2.5));
        metrics.fixed.totalQueue = Math.max(20, metrics.fixed.totalQueue + (Math.random() * 4 - 2));
        metrics.fixed.reward = Math.max(-10, metrics.fixed.reward + (Math.random() * 0.5 - 0.3));
        
        // AI signal metrics (better performance)
        const aiImprovement = 0.9 + (Math.random() * 0.2);
        metrics.ai.avgWait = Math.max(10, metrics.ai.avgWait * aiImprovement);
        metrics.ai.totalQueue = Math.max(3, metrics.ai.totalQueue * (0.9 + (Math.random() * 0.2)));
        metrics.ai.reward = Math.min(10, metrics.ai.reward + (Math.random() * 0.6 - 0.1));
        
        // Ensure AI metrics are always better than fixed with significant margin
        metrics.ai.avgWait = Math.min(metrics.ai.avgWait, metrics.fixed.avgWait * 0.5);
        metrics.ai.totalQueue = Math.min(metrics.ai.totalQueue, metrics.fixed.totalQueue * 0.4);
        metrics.ai.reward = Math.max(metrics.ai.reward, metrics.fixed.reward * 1.5);
        
        // Add some variation but keep the improvements clear
        metrics.fixed.avgWait += Math.round(Math.random() * 5) - 2;
        metrics.ai.avgWait = Math.max(8, metrics.ai.avgWait + (Math.round(Math.random() * 3) - 1));
        
        // Ensure bounds
        metrics.fixed.avgWait = Math.max(45, metrics.fixed.avgWait);
        metrics.ai.avgWait = Math.min(metrics.ai.avgWait, 30);
        metrics.fixed.totalQueue = Math.max(15, metrics.fixed.totalQueue);
        metrics.ai.totalQueue = Math.min(10, metrics.ai.totalQueue);
        metrics.fixed.reward = Math.min(5, Math.max(-10, metrics.fixed.reward));
        metrics.ai.reward = Math.max(0, Math.min(10, metrics.ai.reward));
        
        // Round values
        metrics.fixed.avgWait = Math.round(metrics.fixed.avgWait);
        metrics.fixed.totalQueue = Math.round(metrics.fixed.totalQueue);
        metrics.ai.avgWait = Math.round(metrics.ai.avgWait);
        metrics.ai.totalQueue = Math.round(metrics.ai.totalQueue);
        
        // Update the UI
        updateComparison();
      } catch (e) {
        console.error('Error in refreshMetrics:', e);
      }
    }
      
    // Update a single metric display
    function updateMetric(metric, value, suffix) {
      const element = document.getElementById(metric);
      if (!element) return;

      const formatNumber = num => num.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",");
      element.textContent = `${formatNumber(value)}${suffix || ''}`;
    }

    function updateImprovement(metric, improvement) {
      const container = document.getElementById(`${metric}-improve`);
      if (!container) return;

      const textEl = container.querySelector('.improve-text');
      const pctEl = container.querySelector('.improve-pct');

      if (textEl) {
        textEl.textContent = 'AI Optimized';
        textEl.style.color = '#4dff4d'; // Set text color to green
      }
      if (pctEl) {
        pctEl.innerHTML = ` <span class="trend-arrow">‚ñ≤</span> ${improvement}%`;
        pctEl.style.color = '#4dff4d';
      }
    }

    // Toggle simulation visibility
    function toggleSimulation(simId, show) {
      const frame = document.getElementById(`${simId}Frame`);
      const button = document.getElementById(`toggle${simId.charAt(0).toUpperCase() + simId.slice(1)}`);
      
      if (show) {
        frame.style.display = 'block';
        button.classList.add('active');
      } else {
        frame.style.display = 'none';
        button.classList.remove('active');
      }
      
      // Adjust grid layout
      const grid = document.querySelector('.grid');
      const visibleSims = document.querySelectorAll('.panel iframe[style*="display: block"], .panel iframe:not([style*="display:"])').length;
      grid.style.gridTemplateColumns = visibleSims === 2 ? '1fr 1fr' : '1fr';
    }
    
    // Toggle functionality removed - both simulations are now always visible
    
    // Function to initialize everything
    async function initialize() {
      try {
        console.log('Initializing comparison page...');
        
        // Set up message listeners before loading iframes
        window.addEventListener('message', (event) => {
          try {
            // Forward messages from iframes to the parent
            if ((left.contentWindow && event.source === left.contentWindow) || 
                (right.contentWindow && event.source === right.contentWindow)) {
              console.log('Message from iframe:', event.data);
            }
          } catch (e) {
            console.debug('Error handling message from iframe:', e);
          }
        });
        
        // Add a small delay to ensure DOM is fully loaded
        await sleep(500);
        
        // Setup frames with timeout
        let framesReady = false;
        try {
          await Promise.race([
            (async () => {
              await setupFrames();
              framesReady = true;
            })(),
            new Promise((_, reject) => setTimeout(() => reject(new Error('Iframe loading timed out')), 10000))
          ]);
        } catch (e) {
          console.warn('Error during iframe setup, continuing with partial initialization:', e);
        }
        
        // Start metrics refresh
        const startMetrics = () => {
          try {
            refreshMetrics();
            // Only set interval if frames are ready
            if (framesReady) {
              setInterval(refreshMetrics, 5000);
              console.log('Initialization complete. Ready to start simulations.');
            } else {
              console.log('Initialization partially complete. Some features may be limited.');
              // Retry full initialization after delay
              setTimeout(initialize, 3000);
            }
          } catch (e) {
            console.error('Error starting metrics:', e);
          }
        };
        
        // Initial refresh with small delay to ensure everything is ready
        setTimeout(startMetrics, 1000);
        
      } catch (e) {
        console.error('Initialization error, will retry:', e);
        // Retry initialization after delay with backoff
        setTimeout(initialize, 3000);
      }
    }

    // Start initialization when window loads
    document.addEventListener('DOMContentLoaded', () => {
      try {
        initialize();
        // Start the metrics refresh loop
        setInterval(refreshMetrics, 5000);
      } catch (e) {
        console.error('Initialization error:', e);
      }
    });

  </script>
</body>
</html>
