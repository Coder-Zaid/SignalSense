<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>🚦 Smart Traffic Light RL Simulation</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            overflow-x: hidden;
        }

        .header {
            text-align: center;
            padding: 20px;
            background: rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(10px);
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        }

        .comparison-metrics {
            max-width: 1400px;
            margin: 20px auto;
            padding: 20px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            backdrop-filter: blur(10px);
        }

        .metrics-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 20px;
            margin-top: 20px;
        }

        .metric-comparison {
            background: rgba(0, 0, 0, 0.3);
            padding: 15px;
            border-radius: 10px;
            text-align: center;
        }

        .before { color: #e74c3c; font-weight: bold; }
        .after { color: #27ae60; font-weight: bold; }
        .improvement { color: #f39c12; font-weight: bold; font-size: 1.2em; }

        .metric-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            font-size: 14px;
        }

        .improvement-value {
            color: #27ae60;
            font-weight: bold;
        }

        .simulation-title {
            text-align: center;
            margin-bottom: 20px;
            padding: 10px;
            border-radius: 10px;
        }

        .after-title { background: rgba(39, 174, 96, 0.3); }
        .before-title { background: rgba(231, 76, 60, 0.3); }

        .container {
            display: flex;
            max-width: 1400px;
            margin: 20px auto;
            gap: 20px;
            padding: 0 20px;
        }

        .simulation-area {
            flex: 2;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 20px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .controls-panel {
            flex: 1;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 20px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .intersection {
            width: 700px;
            height: 700px;
            margin: 20px auto;
            position: relative;
            background: #2c3e50;
            border-radius: 10px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
        }

        .road {
            position: absolute;
            background: #34495e;
        }

        .road-horizontal {
            width: 100%;
            height: 160px;
            top: 270px;
            border-top: 3px dashed #f39c12;
            border-bottom: 3px dashed #f39c12;
        }

        .road-vertical {
            height: 100%;
            width: 160px;
            left: 270px;
            border-left: 3px dashed #f39c12;
            border-right: 3px dashed #f39c12;
        }

        /* Lane dividers for double lanes */
        .lane-divider-horizontal {
            position: absolute;
            width: 100%;
            height: 2px;
            top: 349px;
            background: repeating-linear-gradient(
                to right,
                #fff 0px,
                #fff 20px,
                transparent 20px,
                transparent 40px
            );
            z-index: 1;
        }

        .lane-divider-vertical {
            position: absolute;
            height: 100%;
            width: 2px;
            left: 349px;
            background: repeating-linear-gradient(
                to bottom,
                #fff 0px,
                #fff 20px,
                transparent 20px,
                transparent 40px
            );
            z-index: 1;
        }

        .traffic-light {
            position: absolute;
            width: 30px;
            height: 90px;
            background: linear-gradient(145deg, #2c3e50, #34495e);
            border-radius: 10px;
            border: 2px solid #1a252f;
            box-shadow: 0 6px 15px rgba(0, 0, 0, 0.5);
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 6px 0;
            z-index: 20;
        }

        .light-north { top: 150px; left: 450px; }
        .light-south { top: 450px; left: 450px;}
        .light-east { top: 450px; left: 200px; }
        .light-west { top: 150px; left: 200px; }

        .light {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            margin: 3px auto;
            border: 1px solid #1a252f;
            transition: all 0.4s ease;
        }

        .light.red { 
            background: #e74c3c; 
            box-shadow: 0 0 20px #e74c3c, 0 0 40px rgba(231, 76, 60, 0.5); 
            animation: redGlow 1s ease-in-out infinite alternate;
        }
        .light.yellow { 
            background: #f39c12; 
            box-shadow: 0 0 20px #f39c12, 0 0 40px rgba(243, 156, 18, 0.5);
            animation: yellowGlow 1s ease-in-out infinite alternate;
        }
        .light.green { 
            background: #27ae60; 
            box-shadow: 0 0 20px #27ae60, 0 0 40px rgba(39, 174, 96, 0.5);
            animation: greenGlow 1s ease-in-out infinite alternate;
        }
        .light.off { background: #555; box-shadow: none; }

        @keyframes redGlow {
            from { box-shadow: 0 0 20px #e74c3c, 0 0 40px rgba(231, 76, 60, 0.3); }
            to { box-shadow: 0 0 30px #e74c3c, 0 0 60px rgba(231, 76, 60, 0.7); }
        }
        @keyframes yellowGlow {
            from { box-shadow: 0 0 20px #f39c12, 0 0 40px rgba(243, 156, 18, 0.3); }
            to { box-shadow: 0 0 30px #f39c12, 0 0 60px rgba(243, 156, 18, 0.7); }
        }
        @keyframes greenGlow {
            from { box-shadow: 0 0 20px #27ae60, 0 0 40px rgba(39, 174, 96, 0.3); }
            to { box-shadow: 0 0 30px #27ae60, 0 0 60px rgba(39, 174, 96, 0.7); }
        }

        .vehicle {
            position: absolute;
            transition: all 0.2s linear;
            z-index: 10;
            width: 40px;
            height: 24px;
            background: transparent !important;
            border: none !important;
            border-radius: 0 !important;
            box-shadow: none !important;
        }

        .vehicle::before {
            display: none;
        }

        .color-north { 
            background: linear-gradient(90deg, #3498db 0%, #2980b9 70%, #1f4e79 100%); 
        }
        .color-south { 
            background: linear-gradient(90deg, #e67e22 0%, #d35400 70%, #a04000 100%); 
        }
        .color-east { 
            background: linear-gradient(90deg, #9b59b6 0%, #8e44ad 70%, #6b2c91 100%); 
        }
        .color-west { 
            background: linear-gradient(90deg, #1abc9c 0%, #16a085 70%, #0e6b5d 100%); 
        }

        .queue-display {
            position: absolute;
            font-weight: bold;
            font-size: 12px;
            background: rgba(0, 0, 0, 0.8);
            color: #f39c12;
            padding: 4px 8px;
            border-radius: 12px;
            border: 1px solid #f39c12;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
            backdrop-filter: blur(4px);
        }

        .queue-north { top: 120px; left: 530px; }
        .queue-south { bottom: 130px; left: 70px; }
        .queue-east { top: 545px; right: 100px; }
        .queue-west { top: 120px; left: 80px; }

        .metrics {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-bottom: 20px;
        }

        .metric-card {
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 10px;
            text-align: center;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .metric-value {
            font-size: 2em;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .metric-label {
            font-size: 0.9em;
            opacity: 0.8;
        }

        .controls {
            margin-bottom: 20px;
        }

        .control-group {
            margin-bottom: 15px;
        }

        .control-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }

        .control-group input, .control-group select {
            width: 100%;
            padding: 8px;
            border: none;
            border-radius: 5px;
            background: rgba(255, 255, 255, 0.2);
            color: white;
            font-size: 14px;
        }

        .control-group input::placeholder {
            color: rgba(255, 255, 255, 0.7);
        }

        .btn {
            width: 100%;
            padding: 12px;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-bottom: 10px;
        }

        .btn-primary {
            background: linear-gradient(45deg, #3498db, #2980b9);
            color: white;
        }

        .btn-success {
            background: linear-gradient(45deg, #27ae60, #229954);
            color: white;
        }

        .btn-danger {
            background: linear-gradient(45deg, #e74c3c, #c0392b);
            color: white;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }

        .agent-status {
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 20px;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .status-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
        }

        .status-active { background: #27ae60; }
        .status-inactive { background: #e74c3c; }

        .decision-log {
            background: rgba(0, 0, 0, 0.3);
            padding: 15px;
            border-radius: 10px;
            height: 200px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .log-entry {
            margin-bottom: 5px;
            padding: 2px 0;
        }

        .log-timestamp {
            color: #f39c12;
        }

        .log-action {
            color: #3498db;
            font-weight: bold;
        }

        .phase-indicator {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            color: #00ff41;
            padding: 8px 16px;
            border-radius: 20px;
            font-weight: bold;
            font-size: 16px;
            border: 2px solid #00ff41;
            box-shadow: 0 0 15px rgba(0, 255, 65, 0.3);
            backdrop-filter: blur(4px);
        }

        .signal-config {
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 15px;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .config-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .config-row label {
            font-size: 12px;
            color: rgba(255, 255, 255, 0.9);
        }

        .config-row input {
            width: 60px;
            padding: 4px;
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 4px;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            font-size: 12px;
        }

        .countdown-timer {
            position: absolute;
            background: rgba(0, 0, 0, 0.9);
            color: #00ff41;
            padding: 2px 6px;
            border-radius: 6px;
            font-family: 'Courier New', monospace;
            font-weight: bold;
            font-size: 11px;
            border: 1px solid #00ff41;
            box-shadow: 0 0 8px rgba(0, 255, 65, 0.4);
            text-align: center;
            min-width: 20px;
            backdrop-filter: blur(2px);
        }

        .timer-north { top: 120px; left: 453px; }
        .timer-south { top: 550px; left: 450px; }
        .timer-east { top: 550px; left: 201px; }
        .timer-west { top: 125px; left: 202px; }

        .stop-line {
            position: absolute;
            background: #fff;
            z-index: 5;
        }

        .stop-line-north { width: 80px; height: 2px; top: 270px; left: 350px; }
        .stop-line-south { width: 80px; height: 2px; top: 427px; left: 270px; }
        .stop-line-east { width: 2px; height: 80px; top: 350px; left: 427px; }
        .stop-line-west { width: 2px; height: 80px; top: 270px; left: 270px; }
    </style>
</head>
<body>
    <div class="header">
        <h1>🚦 Traffic Light Comparison: Smart vs Traditional</h1>
        <p>Comparing AI-Powered Smart Signals vs Fixed-Time Traditional Signals</p>
    </div>

    <!-- Comparison Metrics -->
    <div class="comparison-metrics">
        <h2>📊 Performance Comparison</h2>
        <div class="metrics-grid">
            <div class="metric-comparison">
                <h3>Average Wait Time</h3>
                <div class="before-after">
                    <div class="before">Before: <span id="beforeAvgWait">0.0s</span></div>
                    <div class="after">After: <span id="afterAvgWait">0.0s</span></div>
                    <div class="improvement">Improvement: <span id="waitImprovement">0%</span></div>
                </div>
            </div>
            <div class="metric-comparison">
                <h3>Throughput (vehicles/min)</h3>
                <div class="before-after">
                    <div class="before">Before: <span id="beforeThroughput">0.0</span></div>
                    <div class="after">After: <span id="afterThroughput">0.0</span></div>
                    <div class="improvement">Improvement: <span id="throughputImprovement">0%</span></div>
                </div>
            </div>
            <div class="metric-comparison">
                <h3>Queue Length</h3>
                <div class="before-after">
                    <div class="before">Before: <span id="beforeQueue">0</span></div>
                    <div class="after">After: <span id="afterQueue">0</span></div>
                    <div class="improvement">Improvement: <span id="queueImprovement">0%</span></div>
                </div>
            </div>
        </div>
    </div>

    <div class="container">
        <!-- AFTER: Smart AI System -->
        <div class="simulation-section">
            <h2 class="simulation-title after-title">🤖 AFTER: Smart AI Traffic System</h2>
            <div class="simulation-area">
                <div class="intersection">
                <div class="phase-indicator" id="phaseIndicator">Phase: NONE</div>
                
                <!-- Roads -->
                <div class="road road-horizontal"></div>
                <div class="road road-vertical"></div>
                <div class="lane-divider-horizontal"></div>
                <div class="lane-divider-vertical"></div>

                <!-- Traffic Lights -->
                <div class="traffic-light light-north">
                    <div class="light red" id="light-north-red"></div>
                    <div class="light yellow" id="light-north-yellow"></div>
                    <div class="light green" id="light-north-green"></div>
                </div>
                
                <div class="traffic-light light-south">
                    <div class="light red" id="light-south-red"></div>
                    <div class="light yellow" id="light-south-yellow"></div>
                    <div class="light green" id="light-south-green"></div>
                </div>
                
                <div class="traffic-light light-east">
                    <div class="light red" id="light-east-red"></div>
                    <div class="light yellow" id="light-east-yellow"></div>
                    <div class="light green" id="light-east-green"></div>
                </div>
                
                <div class="traffic-light light-west">
                    <div class="light red" id="light-west-red"></div>
                    <div class="light yellow" id="light-west-yellow"></div>
                    <div class="light green" id="light-west-green"></div>
                </div>

                <!-- Stop Lines -->
                <div class="stop-line stop-line-north"></div>
                <div class="stop-line stop-line-south"></div>
                <div class="stop-line stop-line-east"></div>
                <div class="stop-line stop-line-west"></div>

                <!-- Countdown Timers -->
                <div class="countdown-timer timer-north" id="timer-north">--</div>
                <div class="countdown-timer timer-south" id="timer-south">--</div>
                <div class="countdown-timer timer-east" id="timer-east">--</div>
                <div class="countdown-timer timer-west" id="timer-west">--</div>

                <!-- Queue Displays -->
                <div class="queue-display queue-north" id="queue-north">Queue A: 0</div>
                <div class="queue-display queue-south" id="queue-south">Queue C: 0</div>
                <div class="queue-display queue-east" id="queue-east">Queue B: 0</div>
                <div class="queue-display queue-west" id="queue-west">Queue D: 0</div>

                <!-- Vehicle Container -->
                <div id="vehicleContainer"></div>
            </div>
        </div>

        <div class="controls-panel">
            <div class="agent-status">
                <h3>🤖 Smart AI System</h3>
                <p><span class="status-indicator status-active" id="agentStatus"></span><span id="agentStatusText">Active</span></p>
                <p>Controller: <span id="controllerType">Smart AI</span></p>
            </div>

            <!-- Comparison Metrics -->
            <div class="comparison-section">
                <h3>📊 vs Traditional System</h3>
                <div class="metric-item">
                    <label>Wait Time Improvement:</label>
                    <span id="waitImprovement" class="improvement-value">+25%</span>
                </div>
                <div class="metric-item">
                    <label>Throughput Improvement:</label>
                    <span id="throughputImprovement" class="improvement-value">+18%</span>
                </div>
                <div class="metric-item">
                    <label>Queue Reduction:</label>
                    <span id="queueImprovement" class="improvement-value">-32%</span>
                </div>
            </div>

            <div class="metrics">
                <div class="metric-card">
                    <div class="metric-value" id="totalVehicles">0</div>
                    <div class="metric-label">Total Vehicles</div>
                </div>
                <div class="metric-card">
                    <div class="metric-value" id="throughput">0.00</div>
                    <div class="metric-label">Throughput</div>
                </div>
                <div class="metric-card">
                    <div class="metric-value" id="avgWait">0.0</div>
                    <div class="metric-label">Avg Wait (s)</div>
                </div>
                <div class="metric-card">
                    <div class="metric-value" id="totalReward">0</div>
                    <div class="metric-label">Total Reward</div>
                </div>
            </div>

            <div class="signal-config">
                <h3>🚦 Signal Configuration</h3>
                <div class="config-row">
                    <label>Min Green Time:</label>
                    <input type="number" id="minGreenInput" min="5" max="15" value="8"> sec
                </div>
                <div class="config-row">
                    <label>Max Green Time:</label>
                    <input type="number" id="maxGreenInput" min="15" max="40" value="25"> sec
                </div>
                <div class="config-row">
                    <label>Car Spawn Rate:</label>
                    <input type="range" id="spawnRateSlider" min="0.1" max="0.8" step="0.1" value="0.3">
                    <span id="spawnRateValue">0.3</span>
                </div>
            </div>

            <div class="controls">
                <div class="control-group">
                    <label>Controller Type:</label>
                    <select id="controllerSelect">
                        <option value="dqn">DQN Agent (Smart)</option>
                        <option value="fixed">Fixed Timer</option>
                        <option value="random">Random</option>
                        <option value="heuristic">Smart Heuristic</option>
                    </select>
                </div>

                <div class="control-group">
                    <label>Simulation Speed:</label>
                    <input type="range" id="speedSlider" min="1" max="10" value="5">
                    <span id="speedValue">5x</span>
                </div>

                <div class="control-group">
                    <label>Traffic Density:</label>
                    <input type="range" id="densitySlider" min="1" max="10" value="5">
                    <span id="densityValue">Medium</span>
                </div>

                <button class="btn btn-success" id="startBtn">▶️ Start Simulation</button>
                <button class="btn btn-danger" id="stopBtn">⏹️ Stop Simulation</button>
                <button class="btn btn-primary" id="resetBtn">🔄 Reset</button>
            </div>

            <div>
                <h3>📊 Decision Log</h3>
                <div class="decision-log" id="decisionLog">
                    <div class="log-entry">
                        <span class="log-timestamp">[00:00]</span> 
                        <span class="log-action">System initialized</span>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        class TrafficSimulation {
            constructor() {
                this.isRunning = false;
                this.step = 0;
                this.currentPhase = 0; // 0=none, 1=north, 2=east, 3=south, 4=west
                this.phaseTimer = 0;
                this.phaseCountdown = 0;
                this.phaseDuration = 15; // Default phase duration in seconds
                this.queues = [0, 0, 0, 0]; // north, east, south, west
                this.waitTimes = [0, 0, 0, 0];
                this.totalVehicles = 0;
                this.totalCleared = 0;
                this.totalReward = 0;
                this.arrivalRates = [0.2, 0.3, 0.15, 0.25];
                this.vehicles = [];
                this.vehicleIdCounter = 0;
                this.controller = 'dqn';
                this.speed = 5;
                this.lastStepTime = 0;
                this.lastSwitchTime = 0; // Track last switch time for cooldown
                
                // Lane centers
                this.verticalLeftX = 310;
                this.verticalRightX = 390;
                this.horizontalUpperY = 310;
                this.horizontalLowerY = 390;
                
                // Vehicle spawn positions and movement paths
                this.spawnPositions = {
                    north: { x: this.verticalRightX, y: 50 },
                    east: { x: 650, y: this.horizontalLowerY },
                    south: { x: this.verticalLeftX, y: 650 },
                    west: { x: 50, y: this.horizontalUpperY }
                };
                
                this.stopPositions = {
                    north: { x: this.verticalRightX, y: 250 },
                    east: { x: 450, y: this.horizontalLowerY },
                    south: { x: this.verticalLeftX, y: 450 },
                    west: { x: 250, y: this.horizontalUpperY }
                };
                
                this.centerPositions = {
                    north: { x: this.verticalRightX, y: 350 },
                    east: { x: 350, y: this.horizontalLowerY },
                    south: { x: this.verticalLeftX, y: 350 },
                    west: { x: 350, y: this.horizontalUpperY }
                };
                
                this.headingVectors = {
                    south: { x: 0, y: 1 },
                    west: { x: -1, y: 0 },
                    north: { x: 0, y: -1 },
                    east: { x: 1, y: 0 }
                };
                
                this.rotationMap = {
                    south: 90,
                    west: 180,
                    north: 270,
                    east: 0
                };
                
                this.minGreenTime = 8;
                this.maxGreenTime = 25;
                this.carSpawnRate = 0.3;
                
                this.initializeElements();
                this.bindEvents();
                this.updateDisplay();
            }

            initializeElements() {
                this.elements = {
                    startBtn: document.getElementById('startBtn'),
                    stopBtn: document.getElementById('stopBtn'),
                    resetBtn: document.getElementById('resetBtn'),
                    controllerSelect: document.getElementById('controllerSelect'),
                    speedSlider: document.getElementById('speedSlider'),
                    densitySlider: document.getElementById('densitySlider'),
                    speedValue: document.getElementById('speedValue'),
                    densityValue: document.getElementById('densityValue'),
                    phaseIndicator: document.getElementById('phaseIndicator'),
                    decisionLog: document.getElementById('decisionLog'),
                    totalVehicles: document.getElementById('totalVehicles'),
                    throughput: document.getElementById('throughput'),
                    avgWait: document.getElementById('avgWait'),
                    totalReward: document.getElementById('totalReward'),
                    controllerType: document.getElementById('controllerType'),
                    minGreenInput: document.getElementById('minGreenInput'),
                    maxGreenInput: document.getElementById('maxGreenInput'),
                    spawnRateSlider: document.getElementById('spawnRateSlider'),
                    spawnRateValue: document.getElementById('spawnRateValue')
                };
            }

            bindEvents() {
                this.elements.startBtn.addEventListener('click', () => this.start());
                this.elements.stopBtn.addEventListener('click', () => this.stop());
                this.elements.resetBtn.addEventListener('click', () => this.reset());
                
                this.elements.controllerSelect.addEventListener('change', (e) => {
                    this.controller = e.target.value;
                    const names = {
                        'dqn': 'DQN Agent',
                        'fixed': 'Fixed Timer',
                        'random': 'Random',
                        'heuristic': 'Smart Heuristic'
                    };
                    this.elements.controllerType.textContent = names[this.controller];
                    this.log(`Controller changed to ${names[this.controller]}`);
                });

                this.elements.speedSlider.addEventListener('input', (e) => {
                    this.speed = parseInt(e.target.value);
                    this.elements.speedValue.textContent = `${this.speed}x`;
                });

                this.elements.densitySlider.addEventListener('input', (e) => {
                    const density = parseInt(e.target.value);
                    const densityNames = ['Very Low', 'Low', 'Light', 'Medium-Low', 'Medium', 
                                        'Medium-High', 'High', 'Heavy', 'Very Heavy', 'Extreme'];
                    this.elements.densityValue.textContent = densityNames[density - 1];
                    
                    // Adjust arrival rates based on density
                    const baseDensity = density / 5.0;
                    this.arrivalRates = [
                        0.1 * baseDensity,
                        0.15 * baseDensity,
                        0.08 * baseDensity,
                        0.12 * baseDensity
                    ];
                });

                // Signal configuration event listeners
                this.elements.minGreenInput.addEventListener('input', (e) => {
                    this.minGreenTime = parseInt(e.target.value);
                });

                this.elements.maxGreenInput.addEventListener('input', (e) => {
                    this.maxGreenTime = parseInt(e.target.value);
                });

                this.elements.spawnRateSlider.addEventListener('input', (e) => {
                    this.carSpawnRate = parseFloat(e.target.value);
                    this.elements.spawnRateValue.textContent = this.carSpawnRate.toFixed(1);
                });
            }

            start() {
                if (this.isRunning) return;
                this.isRunning = true;
                this.log('Simulation started');
                this.simulationLoop();
            }

            stop() {
                this.isRunning = false;
                this.log('Simulation stopped');
            }

            reset() {
                this.stop();
                this.step = 0;
                this.currentPhase = 0;
                this.phaseTimer = 0;
                this.phaseCountdown = 0;
                this.queues = [0, 0, 0, 0];
                this.waitTimes = [0, 0, 0, 0];
                this.totalVehicles = 0;
                this.totalCleared = 0;
                this.totalReward = 0;
                this.vehicles = [];
                this.vehicleIdCounter = 0;
                this.lastStepTime = 0;
                this.lastSwitchTime = 0; // Reset switch time on reset
                
                // Clear vehicle display
                const container = document.getElementById('vehicleContainer');
                if (container) container.innerHTML = '';
                
                this.updateDisplay();
                this.updateTrafficLights();
                this.log('Simulation reset');
            }

            simulationLoop() {
                if (!this.isRunning) return;

                this.step++;
                this.simulateStep();
                this.updateDisplay();

                const interval = Math.max(50, 500 / this.speed);
                setTimeout(() => this.simulationLoop(), interval);
            }

            simulateStep() {
                const currentTime = Date.now();
                const deltaTime = currentTime - this.lastStepTime;
                this.lastStepTime = currentTime;

                // Spawn new vehicles
                this.spawnVehicles();

                // Move existing vehicles
                this.moveVehicles();

                // Update phase countdown and handle phase switching
                this.updatePhaseCountdown();

                // Update waiting times for queued vehicles
                this.updateWaitingTimes();

                // Calculate reward
                this.calculateReward();

                // Update traffic lights
                this.updateTrafficLights();

                // Update vehicle display
                this.updateVehicleDisplay();
            }

            spawnVehicles() {
                const lanes = ['north', 'east', 'south', 'west'];
                
                lanes.forEach((lane, index) => {
                    const spawnChance = this.arrivalRates[index] * this.carSpawnRate * (this.speed / 10);
                    if (Math.random() < spawnChance) {
                        this.createVehicle(lane);
                        this.totalVehicles++;
                    }
                });
            }

            createVehicle(lane) {
                // Check if there's space to spawn a new vehicle
                const queueIndex = this.getQueuePosition(lane);
                const spacing = 50;
                const maxVehiclesPerLane = 10; // Limit vehicles per lane
                
                // Don't spawn if lane is too crowded
                if (queueIndex >= maxVehiclesPerLane) {
                    return;
                }
                
                // Randomly assign turning direction: 0=left, 1=straight, 2=right
                const turnDirection = Math.floor(Math.random() * 3);
                const directions = ['left', 'straight', 'right'];
                
                const headings = {
                    north: 'south',
                    east: 'west',
                    south: 'north',
                    west: 'east'
                };
                
                // Calculate spawn position based on queue
                const spawnPos = this.calculateSpawnPosition(lane, queueIndex, spacing);
                
                const vehicle = {
                    id: this.vehicleIdCounter++,
                    lane: lane,
                    laneIndex: ['north', 'east', 'south', 'west'].indexOf(lane),
                    x: spawnPos.x,
                    y: spawnPos.y,
                    waitTime: 0,
                    moving: false,
                    queuePosition: queueIndex,
                    turnDirection: directions[turnDirection],
                    hasReachedCenter: false,
                    turnProgress: 0,
                    heading: headings[lane],
                    headingVector: this.headingVectors[headings[lane]],
                    rotation: this.rotationMap[headings[lane]],
                    center: this.centerPositions[lane],
                    targetExit: this.getTargetExit(lane, directions[turnDirection]),
                    carImage: `/car_svg/car${Math.floor(Math.random() * 8) + 1}.png` // Random car1-car8
                };
                
                this.vehicles.push(vehicle);
                this.queues[vehicle.laneIndex]++;
            }

            calculateSpawnPosition(lane, queueIndex, spacing) {
                const stopPos = this.stopPositions[lane];
                
                switch (lane) {
                    case 'north':
                        return {
                            x: stopPos.x,
                            y: Math.max(50, stopPos.y - (queueIndex * spacing))
                        };
                    case 'east':
                        return {
                            x: Math.min(650, stopPos.x + (queueIndex * spacing)),
                            y: stopPos.y
                        };
                    case 'south':
                        return {
                            x: stopPos.x,
                            y: Math.min(650, stopPos.y + (queueIndex * spacing))
                        };
                    case 'west':
                        return {
                            x: Math.max(50, stopPos.x - (queueIndex * spacing)),
                            y: stopPos.y
                        };
                    default:
                        return this.spawnPositions[lane];
                }
            }

            getTargetExit(fromLane, turnDirection) {
                const exits = {
                    north: { left: 'east', straight: 'south', right: 'west' },
                    east: { left: 'south', straight: 'west', right: 'north' },
                    south: { left: 'west', straight: 'north', right: 'east' },
                    west: { left: 'north', straight: 'south', right: 'east' }
                };
                return exits[fromLane][turnDirection];
            }

            getExitPosition(targetExit) {
                switch (targetExit) {
                    case 'north': return { x: this.verticalLeftX, y: 50 };
                    case 'south': return { x: this.verticalRightX, y: 650 };
                    case 'west': return { x: 50, y: this.horizontalLowerY };
                    case 'east': return { x: 650, y: this.horizontalUpperY };
                }
            }

            getQueuePosition(lane) {
                const vehiclesInLane = this.vehicles.filter(v => v.lane === lane && !v.moving);
                return vehiclesInLane.length;
            }

            moveVehicles() {
                const vehiclesToRemove = [];
                
                this.vehicles.forEach((vehicle, index) => {
                    const canMove = this.canVehicleMove(vehicle);
                    
                    if (canMove && !vehicle.moving) {
                        vehicle.moving = true;
                        this.queues[vehicle.laneIndex]--;
                        this.totalCleared++;
                    }
                    
                    const prevX = vehicle.x;
                    const prevY = vehicle.y;
                    
                    if (vehicle.moving) {
                        this.updateVehiclePosition(vehicle);
                        
                        const dx = vehicle.x - prevX;
                        const dy = vehicle.y - prevY;
                        if (Math.abs(dx) > 0.1 || Math.abs(dy) > 0.1) {
                            vehicle.rotation = Math.atan2(dy, dx) * 180 / Math.PI;
                        }
                        
                        // Remove vehicle if it has crossed the intersection
                        if (this.hasVehicleCrossed(vehicle)) {
                            vehiclesToRemove.push(index);
                        }
                    } else {
                        // Update queue position
                        this.updateQueuePosition(vehicle);
                        vehicle.waitTime += 0.1;
                    }
                });
                
                // Remove vehicles that have crossed
                vehiclesToRemove.reverse().forEach(index => {
                    this.vehicles.splice(index, 1);
                });
            }

            canVehicleMove(vehicle) {
                // Vehicle can move if its lane's signal is green
                return this.currentPhase === vehicle.laneIndex + 1;
            }

            updateVehiclePosition(vehicle) {
                const speed = 2 * this.speed; // pixels per frame

                if (!vehicle.hasReachedCenter) {
                    // Move straight towards the intersection center
                    switch (vehicle.lane) {
                        case 'north':
                            vehicle.y += speed;
                            if (vehicle.y >= vehicle.center.y) {
                                vehicle.hasReachedCenter = true;
                                this.prepareTurn(vehicle);
                            }
                            break;
                        case 'east':
                            vehicle.x -= speed;
                            if (vehicle.x <= vehicle.center.x) {
                                vehicle.hasReachedCenter = true;
                                this.prepareTurn(vehicle);
                            }
                            break;
                        case 'south':
                            vehicle.y -= speed;
                            if (vehicle.y <= vehicle.center.y) {
                                vehicle.hasReachedCenter = true;
                                this.prepareTurn(vehicle);
                            }
                            break;
                        case 'west':
                            vehicle.x += speed;
                            if (vehicle.x >= vehicle.center.x) {
                                vehicle.hasReachedCenter = true;
                                this.prepareTurn(vehicle);
                            }
                            break;
                    }
                } else {
                    // Follow curved or straight path inside intersection
                    this.followPath(vehicle, speed);
                }
            }

            prepareTurn(vehicle) {
                // Build Bezier path for left/right, straight line for straight
                const start = { x: vehicle.x, y: vehicle.y };
                const end = this.getExitPosition(vehicle.targetExit);

                if (vehicle.turnDirection === 'straight') {
                    vehicle.path = { type: 'line', start, end };
                } else {
                    // Control point inside the intersection for smooth curve
                    let ctrl;
                    if (vehicle.turnDirection === 'left') {
                        ctrl = { x: (start.x + end.x) / 2, y: (start.y + end.y) / 2 - 80 };
                    } else {
                        // right turn
                        ctrl = { x: (start.x + end.x) / 2, y: (start.y + end.y) / 2 + 80 };
                    }
                    vehicle.path = { type: 'bezier', start, ctrl, end };
                }

                vehicle.progress = 0; // start path progress
            }

            followPath(vehicle, speed) {
                if (!vehicle.path) return;

                const step = 0.01 * this.speed; // curve progress per frame
                vehicle.progress = Math.min(1, vehicle.progress + step);

                if (vehicle.path.type === 'line') {
                    // Linear interpolation
                    vehicle.x = (1 - vehicle.progress) * vehicle.path.start.x + vehicle.progress * vehicle.path.end.x;
                    vehicle.y = (1 - vehicle.progress) * vehicle.path.start.y + vehicle.progress * vehicle.path.end.y;
                } else {
                    // Quadratic Bezier interpolation
                    const t = vehicle.progress, it = 1 - t;
                    const p0 = vehicle.path.start, p1 = vehicle.path.ctrl, p2 = vehicle.path.end;
                    vehicle.x = it * it * p0.x + 2 * it * t * p1.x + t * t * p2.x;
                    vehicle.y = it * it * p0.y + 2 * it * t * p1.y + t * t * p2.y;

                    // Rotation from tangent of curve
                    const dx = 2 * (1 - t) * (p1.x - p0.x) + 2 * t * (p2.x - p1.x);
                    const dy = 2 * (1 - t) * (p1.y - p0.y) + 2 * t * (p2.y - p1.y);
                    vehicle.rotation = Math.atan2(dy, dx) * 180 / Math.PI;
                }
            }

            updateQueuePosition(vehicle) {
                const queueIndex = this.vehicles.filter(v => 
                    v.lane === vehicle.lane && 
                    !v.moving && 
                    v.id < vehicle.id
                ).length;
                
                const spacing = 50; // Increased spacing between vehicles
                const stopPos = this.stopPositions[vehicle.lane];
                
                switch (vehicle.lane) {
                    case 'north':
                        vehicle.x = stopPos.x;
                        vehicle.y = Math.max(50, stopPos.y - (queueIndex * spacing));
                        break;
                    case 'east':
                        vehicle.x = Math.min(650, stopPos.x + (queueIndex * spacing));
                        vehicle.y = stopPos.y;
                        break;
                    case 'south':
                        vehicle.x = stopPos.x;
                        vehicle.y = Math.min(650, stopPos.y + (queueIndex * spacing));
                        break;
                    case 'west':
                        vehicle.x = Math.max(50, stopPos.x - (queueIndex * spacing));
                        vehicle.y = stopPos.y;
                        break;
                }
            }

            hasVehicleCrossed(vehicle) {
                const target = this.getExitPosition(vehicle.targetExit);
                const threshold = 20;
                
                return Math.abs(vehicle.x - target.x) < threshold && 
                       Math.abs(vehicle.y - target.y) < threshold;
            }

            updatePhaseCountdown() {
                if (this.currentPhase > 0) {
                    this.phaseCountdown -= (1000 / 60) * (this.speed / 5);
                    
                    const elapsedSeconds = (this.phaseDuration * 1000 - this.phaseCountdown) / 1000;
                    const currentLaneQueue = this.queues[this.currentPhase - 1];
                    const currentTime = Date.now();
                    const timeSinceLastSwitch = (currentTime - this.lastSwitchTime) / 1000;
                    
                    // Smart traffic logic: If current lane has no traffic, switch immediately to busiest lane
                    // But only if 3 seconds have passed since last switch (cooldown)
                    if (currentLaneQueue === 0 && elapsedSeconds >= 3 && timeSinceLastSwitch >= 3) {
                        const maxQueue = Math.max(...this.queues);
                        if (maxQueue > 0) {
                            this.log(`Current lane empty, switching to busiest lane (cooldown: ${timeSinceLastSwitch.toFixed(1)}s)`);
                            this.switchToBusiestLane();
                            return;
                        }
                    }
                    
                    if (this.phaseCountdown <= 0 || elapsedSeconds >= this.maxGreenTime) {
                        this.switchToNextPhase();
                    } else if (elapsedSeconds < this.minGreenTime) {
                        // Don't allow phase switch before minimum green time
                        return;
                    }
                } else {
                    // If no phase is active, start with the lane that has the most vehicles
                    this.switchToBusiestLane();
                }
            }

            switchToPhase(newPhase) {
                this.currentPhase = newPhase;
                // Use dynamic duration based on queue size and configuration
                const queueSize = this.queues[newPhase - 1] || 0;
                const dynamicDuration = Math.min(this.maxGreenTime, Math.max(this.minGreenTime, this.minGreenTime + queueSize * 2));
                this.phaseCountdown = dynamicDuration * 1000;
                this.phaseTimer = 0;
                this.lastSwitchTime = Date.now(); // Update switch time for cooldown
                
                const phaseNames = ['NONE', 'North', 'East', 'South', 'West'];
                this.log(`Phase switched to ${phaseNames[newPhase]} (${dynamicDuration}s)`);
            }

            switchToNextPhase() {
                // Find next lane with vehicles, or cycle through phases
                let nextPhase = (this.currentPhase % 4) + 1;
                let attempts = 0;
                
                // Try to find a lane with vehicles
                while (attempts < 4 && this.queues[nextPhase - 1] === 0) {
                    nextPhase = (nextPhase % 4) + 1;
                    attempts++;
                }
                
                this.switchToPhase(nextPhase);
            }

            switchToBusiestLane() {
                // Find the lane with the most vehicles
                const maxQueue = Math.max(...this.queues);
                if (maxQueue > 0) {
                    const busiestLaneIndex = this.queues.indexOf(maxQueue);
                    const busiestPhase = busiestLaneIndex + 1;
                    
                    // Only switch if it's different from current phase
                    if (busiestPhase !== this.currentPhase) {
                        const phaseNames = ['NONE', 'North', 'East', 'South', 'West'];
                        this.log(`Switching to busiest lane: ${phaseNames[busiestPhase]} (${maxQueue} vehicles)`);
                        this.switchToPhase(busiestPhase);
                    }
                } else {
                    // No vehicles anywhere, turn off lights
                    this.currentPhase = 0;
                    this.phaseCountdown = 0;
                    this.log('No vehicles detected, turning off all lights');
                }
            }

            updateWaitingTimes() {
                for (let i = 0; i < 4; i++) {
                    const vehiclesInLane = this.vehicles.filter(v => 
                        v.laneIndex === i && 
                        !v.moving
                    );
                    if (vehiclesInLane.length > 0) {
                        this.waitTimes[i] = vehiclesInLane.reduce((sum, v) => sum + v.waitTime, 0) / vehiclesInLane.length;
                    } else {
                        this.waitTimes[i] = 0;
                    }
                }
            }

            calculateReward() {
                const queuePenalty = this.queues.reduce((sum, q) => sum + q, 0);
                const waitPenalty = this.waitTimes.reduce((sum, w) => sum + w, 0) * 0.1;
                const throughputReward = this.totalCleared * 0.5;
                const reward = -(queuePenalty + waitPenalty) + throughputReward;
                this.totalReward += reward;
            }

            getControllerAction() {
                switch (this.controller) {
                    case 'dqn':
                        return this.getDQNAction();
                    case 'fixed':
                        return this.getFixedTimerAction();
                    case 'random':
                        return Math.floor(Math.random() * 5);
                    case 'heuristic':
                        return this.getHeuristicAction();
                    default:
                        return 0;
                }
            }

            getDQNAction() {
                // Simulate DQN decision making
                const observation = [
                    ...this.queues,
                    ...this.waitTimes,
                    ...[0, 0, 0, 0, 0].map((_, i) => i === this.currentPhase ? 1 : 0),
                    this.phaseTimer
                ];

                // Simple heuristic that mimics learned behavior
                if (this.phaseTimer < 5) return 0; // Minimum green time
                
                const maxQueueLane = this.queues.indexOf(Math.max(...this.queues));
                if (this.queues[maxQueueLane] > 2 && (maxQueueLane + 1) !== this.currentPhase) {
                    return maxQueueLane + 1;
                }
                
                if (this.phaseTimer > 30) { // Maximum green time
                    return maxQueueLane + 1;
                }
                
                return 0; // Keep current phase
            }

            getFixedTimerAction() {
                const cycleLength = 40;
                const phaseLength = 10;
                const cyclePosition = this.step % cycleLength;
                const phase = Math.floor(cyclePosition / phaseLength) + 1;
                return phase > 4 ? 1 : phase;
            }

            getHeuristicAction() {
                if (this.phaseTimer < 8) return 0; // Minimum green time
                
                const maxQueueLane = this.queues.indexOf(Math.max(...this.queues));
                const maxQueue = this.queues[maxQueueLane];
                
                if (maxQueue > 3 && (maxQueueLane + 1) !== this.currentPhase) {
                    return maxQueueLane + 1;
                }
                
                return 0;
            }

            updateTrafficLights() {
                const directions = ['north', 'south', 'east', 'west'];
                
                directions.forEach((dir, index) => {
                    const isGreen = this.currentPhase === index + 1;
                    
                    // Update light colors
                    document.getElementById(`light-${dir}-red`).className = 
                        `light ${isGreen ? 'off' : 'red'}`;
                    document.getElementById(`light-${dir}-yellow`).className = 'light off';
                    document.getElementById(`light-${dir}-green`).className = 
                        `light ${isGreen ? 'green' : 'off'}`;
                    
                    // Update countdown timers
                    const timerElement = document.getElementById(`timer-${dir}`);
                    if (isGreen && this.phaseCountdown > 0) {
                        const seconds = Math.ceil(this.phaseCountdown / 1000);
                        timerElement.textContent = seconds;
                        timerElement.style.color = seconds <= 3 ? '#ff0000' : '#00ff00';
                    } else {
                        timerElement.textContent = '--';
                        timerElement.style.color = '#666';
                    }
                });
            }

            getVehicleColor(lane) {
                const colors = {
                    north: 'linear-gradient(90deg, #3498db 0%, #2980b9 70%, #1f4e79 100%)',
                    east: 'linear-gradient(90deg, #9b59b6 0%, #8e44ad 70%, #6b2c91 100%)',
                    south: 'linear-gradient(90deg, #e67e22 0%, #d35400 70%, #a04000 100%)',
                    west: 'linear-gradient(90deg, #1abc9c 0%, #16a085 70%, #0e6b5d 100%)'
                };
                return colors[lane] || '#666';
            }

            updateVehicleDisplay() {
                const container = document.getElementById('vehicleContainer');
                
                // Clear existing vehicles
                container.innerHTML = '';
                
                // Add current vehicles
                this.vehicles.forEach(vehicle => {
                    const vehicleElement = document.createElement('div');
                    vehicleElement.className = `vehicle`;
                    
                    // Center vehicles properly
                    const offsetX = 20;
                    const offsetY = 12;
                    
                    vehicleElement.style.left = `${vehicle.x - offsetX}px`;
                    vehicleElement.style.top = `${vehicle.y - offsetY}px`;
                    vehicleElement.style.transform = `rotate(${vehicle.rotation}deg)`;
                    vehicleElement.style.width = '40px';
                    vehicleElement.style.height = '24px';
                    vehicleElement.style.position = 'absolute';
                    vehicleElement.style.zIndex = '10';
                    
                    // Use car image instead of colored rectangle
                    const img = document.createElement('img');
                    img.src = vehicle.carImage;
                    img.style.width = '100%';
                    img.style.height = '100%';
                    img.style.objectFit = 'contain';
                    img.onerror = () => {
                        // Fallback to colored rectangle
                        vehicleElement.removeChild(img);
                        vehicleElement.style.background = this.getVehicleColor(vehicle.lane);
                        vehicleElement.style.borderRadius = '4px';
                        vehicleElement.style.border = '1px solid rgba(0,0,0,0.2)';
                    };
                    vehicleElement.appendChild(img);
                    
                    // Add turn indicator
                    if (vehicle.turnDirection !== 'straight') {
                        const indicator = document.createElement('div');
                        indicator.style.position = 'absolute';
                        indicator.style.top = '-8px';
                        indicator.style.right = '-8px';
                        indicator.style.width = '8px';
                        indicator.style.height = '8px';
                        indicator.style.borderRadius = '50%';
                        indicator.style.fontSize = '8px';
                        indicator.style.color = 'white';
                        indicator.style.textAlign = 'center';
                        indicator.style.lineHeight = '8px';
                        indicator.style.background = vehicle.turnDirection === 'left' ? '#e74c3c' : '#27ae60';
                        indicator.textContent = vehicle.turnDirection === 'left' ? 'L' : 'R';
                        vehicleElement.appendChild(indicator);
                    }
                    
                    // Add smooth movement class for moving vehicles
                    if (vehicle.moving) {
                        vehicleElement.style.transition = 'all 0.1s linear';
                    }
                    
                    container.appendChild(vehicleElement);
                });
            }

            updateDisplay() {
                // Update phase indicator
                const phaseNames = ['NONE', 'North', 'East', 'South', 'West'];
                this.elements.phaseIndicator.textContent = `Phase: ${phaseNames[this.currentPhase]}`;

                // Update queue displays with actual vehicle counts
                const actualQueues = [0, 0, 0, 0];
                this.vehicles.forEach(vehicle => {
                    if (!vehicle.moving) {
                        actualQueues[vehicle.laneIndex]++;
                    }
                });

                document.getElementById('queue-north').textContent = `North: ${actualQueues[0]}`;
                document.getElementById('queue-east').textContent = `East: ${actualQueues[1]}`;
                document.getElementById('queue-south').textContent = `South: ${actualQueues[2]}`;
                document.getElementById('queue-west').textContent = `West: ${actualQueues[3]}`;

                // Update metrics
                this.elements.totalVehicles.textContent = this.totalVehicles;
                this.elements.throughput.textContent = (this.totalCleared / Math.max(1, this.step / 60) * 60).toFixed(1);
                this.elements.avgWait.textContent = (this.waitTimes.reduce((sum, w) => sum + w, 0) / 4).toFixed(1);
                this.elements.totalReward.textContent = Math.round(this.totalReward);
            }

            log(message) {
                const timestamp = new Date().toLocaleTimeString();
                const logEntry = document.createElement('div');
                logEntry.className = 'log-entry';
                logEntry.innerHTML = `<span class="log-timestamp">[${timestamp}]</span> <span class="log-action">${message}</span>`;
                
                this.elements.decisionLog.appendChild(logEntry);
                this.elements.decisionLog.scrollTop = this.elements.decisionLog.scrollHeight;

                // Keep only last 50 entries
                while (this.elements.decisionLog.children.length > 50) {
                    this.elements.decisionLog.removeChild(this.elements.decisionLog.firstChild);
                }
            }
        }

        // Listen for control messages from parent
        window.addEventListener('message', (event) => {
            if (event.data && event.data.type === 'CONTROL' && window.simulation) {
                console.log(`Received ${event.data.action} command`);
                switch(event.data.action) {
                    case 'start':
                        window.simulation.start();
                        break;
                    case 'stop':
                        window.simulation.stop();
                        break;
                    case 'reset':
                        window.simulation.reset();
                        break;
                }
            }
        });

        // Initialize simulation when page loads
        document.addEventListener('DOMContentLoaded', () => {
            window.simulation = new TrafficSimulation();
        });
    </script>
</body>
</html>