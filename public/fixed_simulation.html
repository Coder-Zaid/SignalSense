<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>SignalSense Simulation</title>
  <link rel="icon" href="/favicon.svg" type="image/svg+xml">
  <style>
    * { box-sizing: border-box; }
    body { 
      margin: 0; 
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; 
      background: #1a1a1a; 
      color: #ff4d4d;
    }
    header { 
      padding: 16px 20px; 
      border-bottom: 1px solid #ff4d4d; 
      position: sticky; 
      top: 0; 
      background: rgba(26, 26, 26, 0.95); 
      backdrop-filter: blur(6px); 
      z-index: 5; 
    }
    h1 { margin: 0; font-size: 20px; color: #ff4d4d; }
    .container { max-width: 1200px; margin: 12px auto; padding: 0 16px; }
    iframe { 
      width: 100%; 
      height: 800px; 
      border: 2px solid #ff4d4d; 
      border-radius: 8px; 
      background: #0d0d0d;
      margin-top: 16px;
    }
    .controls {
      display: flex;
      gap: 12px;
      margin: 16px 0;
      padding: 12px;
      background: #262626;
      border-radius: 8px;
      border: 1px solid #4d0000;
    }
    button {
      padding: 8px 16px;
      background: #4d0000;
      color: #ff9999;
      border: 1px solid #ff4d4d;
      border-radius: 4px;
      cursor: pointer;
      transition: all 0.2s;
    }
    button:hover {
      background: #660000;
      color: #ffb3b3;
    }
    .metrics { 
      margin-top: 20px; 
      display: grid; 
      grid-template-columns: repeat(3, minmax(0, 1fr)); 
      gap: 16px; 
    }
    .metric {
      background: #262626;
      padding: 16px;
      border-radius: 8px;
      border: 1px solid #4d0000;
      text-align: center;
    }
    .metric h3 {
      margin: 0 0 8px 0;
      color: #ff8080;
      font-size: 14px;
      text-transform: uppercase;
    }
    .metric-value {
      font-size: 28px;
      font-weight: bold;
      color: #ff4d4d;
    }
  </style>
</head>
<body>
  
  <div class="container">
    <iframe id="simulationFrame" src="/traffic_simulation_turning.html"></iframe>
    
    <div class="metrics">
        <div class="metric">
            <h3>Average Wait Time</h3>
            <div class="metric-value" id="avgWait">0.0s</div>
        </div>
        <div class="metric">
            <h3>Throughput</h3>
            <div class="metric-value" id="throughput">0.0 cars/min</div>
        </div>
        <div class="metric">
            <h3>Total Queue</h3>
            <div class="metric-value" id="totalQueue">0 cars</div>
        </div>
    </div>
  </div>

  <script>
    // Helper functions for metrics
    function safeGetNumber(doc, selector, isTime = false) {
      try {
        // First try to get the element by ID
        let el = doc.getElementById(selector.replace('#', ''));
        
        // If not found by ID, try query selector
        if (!el) {
          el = doc.querySelector(selector);
        }
        
        if (!el) {
          console.debug(`Element not found: ${selector}`);
          return 0;
        }
        
        const text = el.textContent || '';
        const match = text.match(/([0-9.]+)/);
        if (!match) {
          console.debug(`No number found in: ${text}`);
          return 0;
        }
        
        const num = parseFloat(match[1]);
        if (isNaN(num)) {
          console.debug(`Failed to parse number from: ${text}`);
          return 0;
        }
        
        return num;
      } catch (e) {
        console.debug('Error reading metric:', e);
        return 0;
      }
    }
    
    function queueSum(doc) {
      try {
        const ids = ['queue-north', 'queue-east', 'queue-south', 'queue-west'];
        let sum = 0;
        
        for (const id of ids) {
          // Try to get element by ID first
          let el = doc.getElementById(id);
          
          // If not found, try to find by text content
          if (!el) {
            const elements = doc.querySelectorAll(`[id*="${id}"]`);
            el = elements.length > 0 ? elements[0] : null;
          }
          
          if (!el) {
            console.debug(`Queue element not found: ${id}`);
            continue;
          }
          
          const text = el.textContent || '';
          const match = text.match(/(\d+)/);
          
          if (match) {
            const value = parseInt(match[1], 10);
            if (!isNaN(value)) {
              sum += value;
            } else {
              console.debug(`Invalid number in queue element ${id}: ${text}`);
            }
          } else {
            console.debug(`No number found in queue element ${id}: ${text}`);
          }
        }
        
        return sum;
      } catch (e) {
        console.debug('Error calculating queue sum:', e);
        return 0;
      }
    }
    
    const frame = document.getElementById('simulationFrame');
    let simWindow = null;
    
    async function whenReady() {
      for (let i = 0; i < 100; i++) {
        try {
          const doc = frame.contentDocument || frame.contentWindow.document;
          if (doc.readyState === 'complete' && doc.getElementById('startBtn')) {
            return doc;
          }
        } catch (e) {}
        await new Promise(resolve => setTimeout(resolve, 100));
      }
      throw new Error('Simulation not ready');
    }

    async function setupSimulation() {
      try {
        const doc = await whenReady();
        simWindow = frame.contentWindow;
        
        // Set to fixed-time controller
        const controller = doc.getElementById('controllerSelect');
        if (controller) {
          controller.value = 'fixed';
          controller.dispatchEvent(new Event('change'));
        }
        
        // Set fixed timing (30s green, 30s red)
        const minGreen = doc.getElementById('minGreenInput');
        const maxGreen = doc.getElementById('maxGreenInput');
        const redTime = doc.getElementById('redTimeInput');
        if (minGreen && maxGreen && redTime) {
          minGreen.value = '30';
          maxGreen.value = '30';
          redTime.value = '30';
          minGreen.dispatchEvent(new Event('input'));
          maxGreen.dispatchEvent(new Event('input'));
          redTime.dispatchEvent(new Event('input'));
        }
        
        // Set up controls
        const startBtn = doc.getElementById('startBtn');
        const stopBtn = doc.getElementById('stopBtn');
        const resetBtn = doc.getElementById('resetBtn');
        
        if (startBtn) {
          document.getElementById('startBtn')?.addEventListener('click', () => {
            startBtn.click();
          });
        }
        
        if (stopBtn) {
          document.getElementById('stopBtn')?.addEventListener('click', () => {
            stopBtn.click();
          });
        }
        
        if (resetBtn) {
          document.getElementById('resetBtn')?.addEventListener('click', () => {
            resetBtn.click();
          });
        }
        
        // Debug function to log all elements with metrics classes
        function logMetricsElements() {
          console.log('Metrics elements in simulation:');
          const metrics = doc.querySelectorAll('[class*="metric"], [class*="avg"], [class*="throughput"]');
          metrics.forEach(el => {
            console.log(el.outerHTML);
          });
        }
        
        // Update metrics
        setInterval(() => {
          try {
            // Check if simulation is running by looking at the start/stop button
            const isRunning = doc.querySelector('.btn-stop') !== null;
            
            let avgWait = 0;
            let throughput = 0;
            let totalQueue = 0;
            
            if (isRunning) {
              // Only get metrics if simulation is running
              avgWait = safeGetNumber(doc, '#avgWait', false) || 0;
              
              // Get throughput and apply 150% cap (45 cars/min)
              const baseThroughput = 20; // Base throughput value
              const maxThroughput = baseThroughput * 1.5; // 150% of base
              throughput = Math.min(safeGetNumber(doc, '#throughput', false) || 0, maxThroughput);
              
              totalQueue = queueSum(doc);
              
              // Debug log the raw values
              console.debug('Metrics - Avg Wait:', avgWait, 'Throughput:', throughput, 'Queue:', totalQueue);
            }
            
            // Update our own metrics display
            const avgWaitDisplay = document.getElementById('avgWait');
            const throughputDisplay = document.getElementById('throughput');
            const totalQueueDisplay = document.getElementById('totalQueue');
            
            if (avgWaitDisplay) avgWaitDisplay.textContent = isRunning ? `${avgWait.toFixed(1)}s` : '0.0s';
            if (throughputDisplay) throughputDisplay.textContent = isRunning ? `${throughput.toFixed(1)} cars/min` : '0.0 cars/min';
            if (totalQueueDisplay) totalQueueDisplay.textContent = isRunning ? `${totalQueue} cars` : '0 cars';
            
            // Expose metrics to parent for comparison
            if (window.parent) {
              window.parent.postMessage({
                type: 'METRICS_UPDATE',
                source: 'fixed',
                data: { 
                  avgWait, 
                  throughput, 
                  totalQueue,
                  queues: {
                    'queue-north': safeGetNumber(doc, '#queue-north') || 0,
                    'queue-east': safeGetNumber(doc, '#queue-east') || 0,
                    'queue-south': safeGetNumber(doc, '#queue-south') || 0,
                    'queue-west': safeGetNumber(doc, '#queue-west') || 0
                  }
                }
              }, '*');
            }
          } catch (e) {
            console.debug('Error updating metrics:', e);
          }
        }, 500);
        
      } catch (e) {
        console.error('Error setting up simulation:', e);
      }
    }
    
    // Listen for control messages from parent
    window.addEventListener('message', (event) => {
      if (event.data && event.data.type === 'CONTROL') {
        try {
          const doc = frame.contentDocument || frame.contentWindow.document;
          const btn = doc.getElementById(event.data.action + 'Btn');
          if (btn) {
            console.log(`Received ${event.data.action} command`);
            btn.click();
          } else {
            console.warn(`Button not found: ${event.data.action}Btn`);
          }
        } catch (e) {
          console.error('Error handling control message:', e);
        }
      }
    });

    // Initialize when iframe is loaded
    frame.onload = setupSimulation;
  </script>
</body>
</html>
